{"ast":null,"code":"import React, { useCallback, useMemo, useRef, useState, useEffect } from 'react';\nconst List = ({\n  listItems = [],\n  startElmRef,\n  lastElmRef,\n  listRef,\n  loading,\n  Card,\n  listElementHeight,\n  listGap,\n  LoadingList,\n  LoadingMore\n}) => {\n  const getRef = useCallback(index => {\n    return index === 0 ? startElmRef : index === listItems.length - 1 ? lastElmRef : undefined;\n  }, [listItems, startElmRef, lastElmRef]);\n  const isLast = useCallback(index => {\n    return index === listItems.length - 1;\n  }, [listItems]);\n  return useMemo(() => {\n    return React.createElement(\"div\", {\n      id: \"IS-container\",\n      className: \"IS-list-parent\",\n      ref: listRef\n    }, listItems.length ? React.createElement(\"div\", {\n      className: \"IS-list\",\n      style: {\n        paddingTop: 0,\n        paddingBottom: 0\n      }\n    }, listItems.map((item, index) => React.createElement(\"div\", {\n      style: {\n        height: listElementHeight,\n        marginTop: listGap,\n        marginBottom: isLast(index) ? listGap : 0\n      },\n      ref: getRef(index),\n      key: \"IS-list-item-\" + index,\n      className: \"IS-list-item IS-last-item\",\n      id: \"IS-list-item-\" + index\n    }, React.createElement(Card, {\n      item: item\n    }))), loading && listItems.length ? React.createElement(\"div\", {\n      className: \"IS-loading IS-loading-more\"\n    }, LoadingMore ? React.createElement(LoadingMore, null) : React.createElement(\"div\", null, \"Loading More...\")) : null) : React.createElement(\"div\", {\n      className: \"IS-loading IS-h-100\"\n    }, LoadingList ? React.createElement(LoadingList, null) : React.createElement(\"div\", null, \"Loading...\")));\n  }, [listItems, listRef, loading, listElementHeight, listGap, getRef, isLast]);\n};\nconst Scroll = ({\n  totalItems,\n  list,\n  hasMore,\n  loading,\n  nextPage,\n  fetchData,\n  chunkSize,\n  Card,\n  height,\n  listElementHeight = 200,\n  listGap = 10,\n  LoadingList,\n  LoadingMore,\n  goToTop = {},\n  refreshList = {}\n}) => {\n  const {\n    showGoToTop,\n    GoToTopButton,\n    goToTopStyle\n  } = goToTop;\n  const {\n    showRefresh,\n    onRefresh,\n    RefreshButton,\n    refreshButtonStyle\n  } = refreshList;\n  const currentIndex = useRef(0);\n  const startElmObserver = useRef(null);\n  const lastElmObserver = useRef(null);\n  const listRef = useRef(null);\n  const [listItems, setListItems] = useState([]);\n  const cssUpdating = useRef(false);\n  const initList = useRef(false);\n  const refApplied = useRef(false);\n  const prevPage = useRef(undefined);\n  const goingToTop = useRef(false);\n  useEffect(() => {\n    if (!list || !list.length || initList.current) {\n      return;\n    }\n    if (totalItems <= chunkSize * 2) {\n      setListItems(list);\n      initList.current = true;\n      return;\n    }\n    if (hasMore && nextPage === 2) {\n      fetchData(nextPage);\n      return;\n    }\n    if (list.length < chunkSize * 2) return;\n    setListItems(list);\n    initList.current = true;\n  }, [list, chunkSize, totalItems, hasMore, nextPage]);\n  const renderList = () => {\n    if (totalItems <= chunkSize * 2) {\n      return list.length ? true : false;\n    }\n    return list.length < chunkSize * 2 ? false : true;\n  };\n  function isMobileBrowser() {\n    return /Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n  }\n  const applyRef = () => {\n    if (refApplied.current) return true;\n    const listHeight = Number(height);\n    const elementsHeight = listItems.length * (listElementHeight + listGap);\n    if (elementsHeight > listHeight + listElementHeight + listGap + 10) {\n      refApplied.current = true;\n      return true;\n    }\n    return false;\n  };\n  const getSlidingWindow = isScrollDown => {\n    const increment = chunkSize;\n    let firstIndex = isScrollDown ? currentIndex.current + increment : currentIndex.current - increment;\n    return Math.max(firstIndex, 0);\n  };\n  const recycleDOM = firstIndex => {\n    const items = [];\n    const domPageSize = chunkSize * 2;\n    for (let i = 0; i < domPageSize; i++) {\n      if (list[i + firstIndex]) {\n        items.push(list[i + firstIndex]);\n      }\n    }\n    requestAnimationFrame(() => {\n      setListItems([...items]);\n    });\n  };\n  const adjustPaddings = isScrollDown => {\n    if (currentIndex.current === 0) {\n      return;\n    }\n    cssUpdating.current = true;\n    if (!isScrollDown && isMobileBrowser()) {\n      // ===============================this code cut off user touch from the screen for mobile devices=============================== //\n      const listParent = document.querySelector(\".IS-list-parent\");\n      if (listParent) {\n        listParent.style.display = \"none\";\n        setTimeout(() => {\n          listParent.style.display = \"block\";\n        }, 0);\n      }\n      // ===============================this code cut off user touch from the screen for mobile devices=============================== //\n    }\n    const ul = document.querySelector(\".IS-list\");\n    if (ul) {\n      const currentPadTop = parseFloat(ul.style.paddingTop) || 0;\n      parseFloat(ul.style.paddingBottom) || 0;\n      const remPaddingsVal = (listElementHeight + listGap) * chunkSize + listGap;\n      const newPadTop = isScrollDown ? currentPadTop + remPaddingsVal : 0;\n      requestAnimationFrame(() => {\n        const container = document.querySelector(\".IS-list-parent\");\n        if (container) {\n          const scrollPosition = container.scrollTop;\n          ul.style.paddingTop = `${Math.max(newPadTop, 0)}px`;\n          if (!isScrollDown) {\n            container.scrollTop = scrollPosition - currentPadTop;\n          }\n          if (!isScrollDown) {\n            container.scrollTop = container.scrollTop + remPaddingsVal;\n            setTimeout(() => {\n              cssUpdating.current = false;\n            }, 0);\n          } else {\n            cssUpdating.current = false;\n          }\n        }\n      });\n    }\n  };\n  const topSentCallback = entry => {\n    if (cssUpdating.current || goingToTop.current) return;\n    if (currentIndex.current === 0) {\n      requestAnimationFrame(() => {\n        const container = document.querySelector(\".IS-list\");\n        if (container && container.style) {\n          container.style.paddingTop = \"0px\";\n        }\n      });\n    }\n    if (entry.isIntersecting && currentIndex.current !== 0) {\n      const firstIndex = getSlidingWindow(false);\n      adjustPaddings(false);\n      recycleDOM(firstIndex);\n      currentIndex.current = firstIndex;\n    }\n  };\n  const botSentCallback = entry => {\n    const domPageSize = chunkSize * 2;\n    if (currentIndex.current === totalItems - domPageSize || loading || cssUpdating.current || goingToTop.current) {\n      return;\n    }\n    if (entry.isIntersecting) {\n      const firstIndex = getSlidingWindow(true);\n      if (list[firstIndex + chunkSize]) {\n        currentIndex.current = firstIndex;\n        adjustPaddings(true);\n        recycleDOM(firstIndex);\n      } else if (hasMore) {\n        // safe check\n        if (prevPage.current === nextPage) {\n          console.error(\"Observer disconnected due to too many calls with the same arguments\");\n          prevPage.current = undefined;\n          return;\n        }\n        fetchData(nextPage);\n        prevPage.current = nextPage;\n      }\n    }\n  };\n  const startElmRef = node => {\n    if (startElmObserver.current) {\n      startElmObserver.current.disconnect();\n    }\n    startElmObserver.current = new IntersectionObserver(entries => {\n      topSentCallback(entries[0]);\n    });\n    if (node) {\n      startElmObserver.current.observe(node);\n    }\n  };\n  const lastElmRef = node => {\n    if (lastElmObserver.current) {\n      lastElmObserver.current.disconnect();\n    }\n    lastElmObserver.current = new IntersectionObserver(entries => {\n      botSentCallback(entries[0]);\n    });\n    if (node) {\n      lastElmObserver.current.observe(node);\n    }\n  };\n  // const isTouching = useRef(false);\n  // useEffect(() => {\n  //   const handleTouchStart = () => {\n  //     isTouching.current = true;\n  //   };\n  //   const handleTouchEnd = () => {\n  //     isTouching.current = false;\n  //   };\n  //   const handleTouchCancel = () => {\n  //     isTouching.current = false;\n  //   };\n  //   window.addEventListener(\"touchstart\", handleTouchStart);\n  //   window.addEventListener(\"touchend\", handleTouchEnd);\n  //   window.addEventListener(\"touchcancel\", handleTouchCancel);\n  //   return () => {\n  //     window.removeEventListener(\"touchstart\", handleTouchStart);\n  //     window.removeEventListener(\"touchend\", handleTouchEnd);\n  //     window.removeEventListener(\"touchcancel\", handleTouchCancel);\n  //   };\n  // }, [listItems]);\n  const isBottom = () => {\n    if (currentIndex.current !== 0) {\n      return true;\n    }\n    return false;\n  };\n  const scrollToTop = () => {\n    // disable scroll when going to top\n    document.body.classList.add(\"disable-touch\");\n    goingToTop.current = true;\n    const ul = document.querySelector(\".IS-list\");\n    if (ul) {\n      ul.style.paddingTop = `0px`;\n      ul.style.paddingBottom = `0px`;\n      const listParent = document.querySelector(\".IS-list-parent\");\n      if (listParent) {\n        listParent.scrollTop = 0;\n      }\n      const items = [];\n      const domPageSize = chunkSize * 2;\n      for (let i = 0; i < domPageSize; i++) {\n        if (list[i]) {\n          items.push(list[i]);\n        }\n      }\n      requestAnimationFrame(() => {\n        setListItems([...items]);\n      });\n      currentIndex.current = 0;\n    }\n    goingToTop.current = false;\n    document.body.classList.remove(\"disable-touch\");\n  };\n  const renderScrollTopView = () => {\n    var _a, _b;\n    return React.createElement(React.Fragment, null, renderList() && isBottom() && showGoToTop ? React.createElement(React.Fragment, null, GoToTopButton ? React.createElement(\"div\", {\n      onClick: scrollToTop,\n      className: \"IS-top-custom\",\n      style: {\n        borderRadius: (_a = goToTopStyle === null || goToTopStyle === void 0 ? void 0 : goToTopStyle.borderRadius) !== null && _a !== void 0 ? _a : \"none\",\n        boxShadow: (_b = goToTopStyle === null || goToTopStyle === void 0 ? void 0 : goToTopStyle.boxShadow) !== null && _b !== void 0 ? _b : \"none\"\n      }\n    }, React.createElement(GoToTopButton, null)) : React.createElement(\"div\", {\n      onClick: scrollToTop,\n      className: \"IS-top\"\n    }, \"Top\")) : null);\n  };\n  const renderRefreshList = () => {\n    var _a, _b;\n    const refreshState = () => {\n      if (!onRefresh) return;\n      currentIndex.current = 0;\n      startElmObserver.current = null;\n      lastElmObserver.current = null;\n      listRef.current = null;\n      setListItems([]);\n      cssUpdating.current = false;\n      initList.current = false;\n      refApplied.current = false;\n      prevPage.current = undefined;\n      goingToTop.current = false;\n      onRefresh();\n    };\n    return React.createElement(React.Fragment, null, renderList() && showRefresh && currentIndex.current === 0 ? React.createElement(React.Fragment, null, RefreshButton ? React.createElement(\"div\", {\n      onClick: refreshState,\n      className: \"IS-refresh-button-custom\",\n      style: {\n        borderRadius: (_a = refreshButtonStyle === null || refreshButtonStyle === void 0 ? void 0 : refreshButtonStyle.borderRadius) !== null && _a !== void 0 ? _a : \"none\",\n        boxShadow: (_b = refreshButtonStyle === null || refreshButtonStyle === void 0 ? void 0 : refreshButtonStyle.boxShadow) !== null && _b !== void 0 ? _b : \"none\"\n      }\n    }, React.createElement(RefreshButton, null)) : React.createElement(\"div\", {\n      onClick: refreshState,\n      className: \"IS-refresh-button\"\n    }, \"Refresh\")) : null);\n  };\n  return React.createElement(\"div\", {\n    className: \"IS-list-container\",\n    style: {\n      height: height,\n      position: \"relative\"\n    }\n  }, renderRefreshList(), renderScrollTopView(), renderList() ? React.createElement(List, {\n    listItems: listItems,\n    startElmRef: applyRef() ? startElmRef : null,\n    lastElmRef: applyRef() ? lastElmRef : null,\n    listRef: listRef,\n    loading: loading,\n    Card: Card,\n    listElementHeight: listElementHeight,\n    listGap: listGap,\n    LoadingList: LoadingList,\n    LoadingMore: LoadingMore\n  }) : React.createElement(\"div\", {\n    className: \"IS-loading IS-h-100\"\n  }, LoadingList ? React.createElement(LoadingList, null) : React.createElement(\"div\", null, \"Loading...\")));\n};\nconst ChunkedData = {}; // Object with number keys and object values\nvar totalPages = 0;\nvar totalItems = 0;\nfunction useFixedList(chunkSize = 10, listType, DB) {\n  const [nextPage, setNextPage] = useState(0);\n  const [list, setList] = useState([]);\n  const [hasMore, setHasMore] = useState(true);\n  const fetchData = page => {\n    if (page < 1 || !hasMore || !ChunkedData[page]) {\n      return;\n    }\n    setList(lst => [...lst, ...ChunkedData[page]]);\n    setNextPage(page + 1);\n    if (page + 1 > totalPages) {\n      setHasMore(false);\n    }\n  };\n  const createChunks = () => {\n    let pg = 1;\n    for (let i = 0; i < DB.length; i += chunkSize) {\n      const chunk = DB.slice(i, i + chunkSize);\n      ChunkedData[pg] = chunk;\n      ++pg;\n      ++totalPages;\n    }\n    totalItems = totalPages * chunkSize;\n    setNextPage(1);\n  };\n  useEffect(() => {\n    if (listType === \"FIXED\" && DB.length) {\n      createChunks();\n    }\n  }, [DB, listType]);\n  const reset = () => {\n    setHasMore(true);\n    setList([]);\n    totalPages = 0;\n    totalItems = 0;\n    setNextPage(1);\n  };\n  if (listType === \"DYNAMIC\") {\n    // If listType is DYNAMIC, return default values or empty state\n    return {\n      totalItems: 0,\n      list: [],\n      hasMore: false,\n      nextPage: 0,\n      fetchData: () => {},\n      reset\n    };\n  }\n  return {\n    totalItems,\n    list,\n    hasMore,\n    nextPage,\n    fetchData,\n    reset\n  };\n}\nconst InfiniteVertualScroll = ({\n  totalItems,\n  list,\n  hasMore,\n  loading,\n  nextPage,\n  fetchData,\n  chunkSize,\n  Card,\n  height,\n  listElementHeight,\n  listGap,\n  LoadingList,\n  LoadingMore,\n  goToTop,\n  refreshList,\n  listType\n}) => {\n  const {\n    totalItems: fixedTotalItems,\n    list: fixedList,\n    hasMore: fixedHasMore,\n    nextPage: fixedNextPage,\n    fetchData: fixedFetchData,\n    reset: fixedReset\n  } = useFixedList(chunkSize, listType, list);\n  useEffect(() => {\n    if (fixedNextPage === 1 && listType === \"FIXED\") {\n      fixedFetchData(fixedNextPage);\n    }\n    return;\n  }, [fixedNextPage, listType]);\n  return React.createElement(Scroll, {\n    totalItems: listType === \"FIXED\" ? fixedTotalItems : totalItems,\n    hasMore: listType === \"FIXED\" ? fixedHasMore : hasMore,\n    loading: listType === \"FIXED\" ? false : loading,\n    nextPage: listType === \"FIXED\" ? fixedNextPage : nextPage,\n    fetchData: listType === \"FIXED\" ? fixedFetchData : fetchData,\n    list: listType === \"FIXED\" ? fixedList : list,\n    chunkSize: chunkSize,\n    Card: Card,\n    height: height,\n    listElementHeight: listElementHeight,\n    listGap: listGap,\n    LoadingList: LoadingList,\n    LoadingMore: LoadingMore,\n    goToTop: goToTop,\n    refreshList: Object.assign(Object.assign({}, refreshList), {\n      onRefresh: listType === \"FIXED\" ? () => {\n        fixedReset();\n        if (refreshList && refreshList.onRefresh) {\n          refreshList.onRefresh();\n        }\n      } : refreshList && refreshList.onRefresh ? refreshList.onRefresh : () => {}\n    })\n  });\n};\nexport { InfiniteVertualScroll as VirtualInfiniteScroll };","map":{"version":3,"names":["List","listItems","startElmRef","lastElmRef","listRef","loading","Card","listElementHeight","listGap","LoadingList","LoadingMore","getRef","useCallback","index","length","undefined","isLast","useMemo","React","createElement","id","className","ref","style","paddingTop","paddingBottom","map","item","height","marginTop","marginBottom","key","Scroll","totalItems","list","hasMore","nextPage","fetchData","chunkSize","goToTop","refreshList","showGoToTop","GoToTopButton","goToTopStyle","showRefresh","onRefresh","RefreshButton","refreshButtonStyle","currentIndex","useRef","startElmObserver","lastElmObserver","setListItems","useState","cssUpdating","initList","refApplied","prevPage","goingToTop","useEffect","current","renderList","isMobileBrowser","test","navigator","userAgent","applyRef","listHeight","Number","elementsHeight","getSlidingWindow","isScrollDown","increment","firstIndex","Math","max","recycleDOM","items","domPageSize","i","push","requestAnimationFrame","adjustPaddings","listParent","document","querySelector","display","setTimeout","ul","currentPadTop","parseFloat","remPaddingsVal","newPadTop","container","scrollPosition","scrollTop","topSentCallback","entry","isIntersecting","botSentCallback","console","error","node","disconnect","IntersectionObserver","entries","observe","isBottom","scrollToTop","body","classList","add","remove","renderScrollTopView","Fragment","onClick","borderRadius","_a","boxShadow","_b","renderRefreshList","refreshState","position","ChunkedData","totalPages","useFixedList","listType","DB","setNextPage","setList","setHasMore","page","lst","createChunks","pg","chunk","slice","reset","InfiniteVertualScroll","fixedTotalItems","fixedList","fixedHasMore","fixedNextPage","fixedFetchData","fixedReset","Object","assign"],"sources":["/Users/ashutoshshukla/Documents/workspace/npm-workspace/packages/virtual-infinite-scroll/src/components/VirtualInfiniteScroll/List.tsx","/Users/ashutoshshukla/Documents/workspace/npm-workspace/packages/virtual-infinite-scroll/src/components/VirtualInfiniteScroll/Scroll.tsx","/Users/ashutoshshukla/Documents/workspace/npm-workspace/packages/virtual-infinite-scroll/src/components/VirtualInfiniteScroll/useFixedList.ts","/Users/ashutoshshukla/Documents/workspace/npm-workspace/packages/virtual-infinite-scroll/src/components/VirtualInfiniteScroll/VirtualInfiniteScroll.tsx"],"sourcesContent":["import React, { useCallback, useMemo } from \"react\";\nimport { MutableRefObject } from \"react\";\nimport \"./index.css\";\n\ninterface ListProps {\n  listItems: Array<{ [key: string]: any }>; // Array of objects representing the list\n  loading: boolean; // Indicator if data is being loaded\n  Card: React.ComponentType<{ item: any }>; // Card component, rendering individual items\n  listElementHeight: number; // Height of each list element\n  listGap: number; // Gap between list elements\n  LoadingList?: React.ComponentType; // Component to display while loading the list\n  LoadingMore?: React.ComponentType; // Component to display while loading more items\n  startElmRef: any; // Reference to the starting element\n  lastElmRef: any; // Reference to the last element\n  listRef: MutableRefObject<HTMLDivElement | null>; // Reference to the container element holding the list\n}\n\nconst List: React.FC<ListProps> = ({\n  listItems = [],\n  startElmRef,\n  lastElmRef,\n  listRef,\n  loading,\n  Card,\n  listElementHeight,\n  listGap,\n  LoadingList,\n  LoadingMore,\n}) => {\n  const getRef = useCallback(\n    (index: number) => {\n      return index === 0\n        ? startElmRef\n        : index === listItems.length - 1\n        ? lastElmRef\n        : undefined;\n    },\n    [listItems, startElmRef, lastElmRef]\n  );\n\n  const isLast = useCallback(\n    (index: number) => {\n      return index === listItems.length - 1;\n    },\n    [listItems]\n  );\n\n  return useMemo(() => {\n    return (\n      <div id=\"IS-container\" className=\"IS-list-parent\" ref={listRef}>\n        {listItems.length ? (\n          <div className=\"IS-list\" style={{ paddingTop: 0, paddingBottom: 0 }}>\n            {listItems.map((item, index) => (\n              <div\n                style={{\n                  height: listElementHeight,\n                  marginTop: listGap,\n                  marginBottom: isLast(index) ? listGap : 0,\n                }}\n                ref={getRef(index)}\n                key={\"IS-list-item-\" + index}\n                className=\"IS-list-item IS-last-item\"\n                id={\"IS-list-item-\" + index}\n              >\n                <Card item={item} />\n              </div>\n            ))}\n            {loading && listItems.length ? (\n              <div className=\"IS-loading IS-loading-more\">\n                {LoadingMore ? <LoadingMore /> : <div>Loading More...</div>}\n              </div>\n            ) : null}\n          </div>\n        ) : (\n          <div className=\"IS-loading IS-h-100\">\n            {LoadingList ? <LoadingList /> : <div>Loading...</div>}\n          </div>\n        )}\n      </div>\n    );\n  }, [listItems, listRef, loading, listElementHeight, listGap, getRef, isLast]);\n};\n\nexport default List;\n","import React, { useEffect, useRef, useState } from \"react\";\nimport List from \"./List\";\nimport \"./index.css\";\nimport { ScrollProps } from \"./types\";\n\nconst Scroll: React.FC<ScrollProps> = ({\n  totalItems,\n  list,\n  hasMore,\n  loading,\n  nextPage,\n  fetchData,\n  chunkSize,\n  Card,\n  height,\n  listElementHeight = 200,\n  listGap = 10,\n  LoadingList,\n  LoadingMore,\n  goToTop = {},\n  refreshList = {},\n}) => {\n  const { showGoToTop, GoToTopButton, goToTopStyle } = goToTop;\n  const { showRefresh, onRefresh, RefreshButton, refreshButtonStyle } =\n    refreshList;\n  const currentIndex = useRef<number>(0);\n  const startElmObserver = useRef<IntersectionObserver | null>(null);\n  const lastElmObserver = useRef<IntersectionObserver | null>(null);\n  const listRef = useRef<HTMLDivElement | null>(null);\n  const [listItems, setListItems] = useState<Array<{ [key: string]: any }>>([]);\n  const cssUpdating = useRef<boolean>(false);\n  const initList = useRef<boolean>(false);\n  const refApplied = useRef<boolean>(false);\n  const prevPage = useRef<number | undefined>(undefined);\n  const goingToTop = useRef<boolean>(false);\n\n  useEffect(() => {\n    if (!list || !list.length || initList.current) {\n      return;\n    }\n    if (totalItems <= chunkSize * 2) {\n      setListItems(list);\n      initList.current = true;\n      return;\n    }\n    if (hasMore && nextPage === 2) {\n      fetchData(nextPage);\n      return;\n    }\n    if (list.length < chunkSize * 2) return;\n    setListItems(list);\n    initList.current = true;\n  }, [list, chunkSize, totalItems, hasMore, nextPage]);\n\n  const renderList = () => {\n    if (totalItems <= chunkSize * 2) {\n      return list.length ? true : false;\n    }\n    return list.length < chunkSize * 2 ? false : true;\n  };\n\n  function isMobileBrowser() {\n    return /Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n      navigator.userAgent\n    );\n  }\n\n  const applyRef = () => {\n    if (refApplied.current) return true;\n    const listHeight = Number(height);\n    const elementsHeight = listItems.length * (listElementHeight + listGap);\n    if (elementsHeight > listHeight + listElementHeight + listGap + 10) {\n      refApplied.current = true;\n      return true;\n    }\n    return false;\n  };\n\n  const getSlidingWindow = (isScrollDown: boolean) => {\n    const increment = chunkSize;\n    let firstIndex = isScrollDown\n      ? currentIndex.current + increment\n      : currentIndex.current - increment;\n\n    return Math.max(firstIndex, 0);\n  };\n\n  const recycleDOM = (firstIndex: number) => {\n    const items: Array<{ [key: string]: any }> = [];\n    const domPageSize = chunkSize * 2;\n    for (let i = 0; i < domPageSize; i++) {\n      if (list[i + firstIndex]) {\n        items.push(list[i + firstIndex]);\n      }\n    }\n    requestAnimationFrame(() => {\n      setListItems([...items]);\n    });\n  };\n\n  const adjustPaddings = (isScrollDown: boolean) => {\n    if (currentIndex.current === 0) {\n      return;\n    }\n    cssUpdating.current = true;\n    if (!isScrollDown && isMobileBrowser()) {\n      // ===============================this code cut off user touch from the screen for mobile devices=============================== //\n      const listParent = document.querySelector<HTMLElement>(\".IS-list-parent\");\n      if (listParent) {\n        listParent.style.display = \"none\";\n        setTimeout(() => {\n          listParent.style.display = \"block\";\n        }, 0);\n      }\n      // ===============================this code cut off user touch from the screen for mobile devices=============================== //\n    }\n    const ul = document.querySelector<HTMLElement>(\".IS-list\");\n    if (ul) {\n      const currentPadTop = parseFloat(ul.style.paddingTop) || 0;\n      const currentPadBottom = parseFloat(ul.style.paddingBottom) || 0;\n      const remPaddingsVal =\n        (listElementHeight + listGap) * chunkSize + listGap;\n\n      const newPadTop = isScrollDown ? currentPadTop + remPaddingsVal : 0;\n      const newPadBottom = isScrollDown ? 0 : currentPadBottom + remPaddingsVal;\n\n      requestAnimationFrame(() => {\n        const container =\n          document.querySelector<HTMLElement>(\".IS-list-parent\");\n        if (container) {\n          const scrollPosition = container.scrollTop;\n\n          ul.style.paddingTop = `${Math.max(newPadTop, 0)}px`;\n\n          if (!isScrollDown) {\n            container.scrollTop = scrollPosition - currentPadTop;\n          }\n\n          if (!isScrollDown) {\n            container.scrollTop = container.scrollTop + remPaddingsVal;\n            setTimeout(() => {\n              cssUpdating.current = false;\n            }, 0);\n          } else {\n            cssUpdating.current = false;\n          }\n        }\n      });\n    }\n  };\n\n  const topSentCallback = (entry: IntersectionObserverEntry): void => {\n    if (cssUpdating.current || goingToTop.current) return;\n    if (currentIndex.current === 0) {\n      requestAnimationFrame(() => {\n        const container = document.querySelector<HTMLElement>(\".IS-list\");\n        if (container && container.style) {\n          container.style.paddingTop = \"0px\";\n        }\n      });\n    }\n\n    if (entry.isIntersecting && currentIndex.current !== 0) {\n      const firstIndex = getSlidingWindow(false);\n      adjustPaddings(false);\n      recycleDOM(firstIndex);\n      currentIndex.current = firstIndex;\n    }\n  };\n\n  const botSentCallback = (entry: IntersectionObserverEntry): void => {\n    const domPageSize = chunkSize * 2;\n    if (\n      currentIndex.current === totalItems - domPageSize ||\n      loading ||\n      cssUpdating.current ||\n      goingToTop.current\n    ) {\n      return;\n    }\n\n    if (entry.isIntersecting) {\n      const firstIndex = getSlidingWindow(true);\n      if (list[firstIndex + chunkSize]) {\n        currentIndex.current = firstIndex;\n        adjustPaddings(true);\n        recycleDOM(firstIndex);\n      } else if (hasMore) {\n        // safe check\n        if (prevPage.current === nextPage) {\n          console.error(\n            \"Observer disconnected due to too many calls with the same arguments\"\n          );\n          prevPage.current = undefined;\n          return;\n        }\n        fetchData(nextPage);\n        prevPage.current = nextPage;\n      }\n    }\n  };\n\n  const startElmRef = (node: HTMLElement | null) => {\n    if (startElmObserver.current) {\n      startElmObserver.current.disconnect();\n    }\n\n    startElmObserver.current = new IntersectionObserver(\n      (entries: IntersectionObserverEntry[]) => {\n        topSentCallback(entries[0]);\n      }\n    );\n\n    if (node) {\n      startElmObserver.current.observe(node);\n    }\n  };\n\n  const lastElmRef = (node: HTMLElement | null) => {\n    if (lastElmObserver.current) {\n      lastElmObserver.current.disconnect();\n    }\n\n    lastElmObserver.current = new IntersectionObserver(\n      (entries: IntersectionObserverEntry[]) => {\n        botSentCallback(entries[0]);\n      }\n    );\n    if (node) {\n      lastElmObserver.current.observe(node);\n    }\n  };\n\n  // const isTouching = useRef(false);\n  // useEffect(() => {\n  //   const handleTouchStart = () => {\n  //     isTouching.current = true;\n  //   };\n\n  //   const handleTouchEnd = () => {\n  //     isTouching.current = false;\n  //   };\n\n  //   const handleTouchCancel = () => {\n  //     isTouching.current = false;\n  //   };\n\n  //   window.addEventListener(\"touchstart\", handleTouchStart);\n  //   window.addEventListener(\"touchend\", handleTouchEnd);\n  //   window.addEventListener(\"touchcancel\", handleTouchCancel);\n\n  //   return () => {\n  //     window.removeEventListener(\"touchstart\", handleTouchStart);\n  //     window.removeEventListener(\"touchend\", handleTouchEnd);\n  //     window.removeEventListener(\"touchcancel\", handleTouchCancel);\n  //   };\n  // }, [listItems]);\n\n  const isBottom = () => {\n    if (currentIndex.current !== 0) {\n      return true;\n    }\n    return false;\n  };\n\n  const scrollToTop = () => {\n    // disable scroll when going to top\n    document.body.classList.add(\"disable-touch\");\n    goingToTop.current = true;\n    const ul = document.querySelector<HTMLElement>(\".IS-list\");\n    if (ul) {\n      ul.style.paddingTop = `0px`;\n      ul.style.paddingBottom = `0px`;\n      const listParent = document.querySelector(\n        \".IS-list-parent\"\n      ) as HTMLElement;\n      if (listParent) {\n        listParent.scrollTop = 0;\n      }\n      const items: Array<{ [key: string]: any }> = [];\n      const domPageSize = chunkSize * 2;\n      for (let i = 0; i < domPageSize; i++) {\n        if (list[i]) {\n          items.push(list[i]);\n        }\n      }\n      requestAnimationFrame(() => {\n        setListItems([...items]);\n      });\n      currentIndex.current = 0;\n    }\n    goingToTop.current = false;\n    document.body.classList.remove(\"disable-touch\");\n  };\n\n  const renderScrollTopView = () => {\n    return (\n      <>\n        {renderList() && isBottom() && showGoToTop ? (\n          <>\n            {GoToTopButton ? (\n              <div\n                onClick={scrollToTop}\n                className=\"IS-top-custom\"\n                style={{\n                  borderRadius: goToTopStyle?.borderRadius ?? \"none\",\n                  boxShadow: goToTopStyle?.boxShadow ?? \"none\",\n                }}\n              >\n                <GoToTopButton />\n              </div>\n            ) : (\n              <div onClick={scrollToTop} className=\"IS-top\">\n                Top\n              </div>\n            )}\n          </>\n        ) : null}\n      </>\n    );\n  };\n\n  const renderRefreshList = () => {\n    const refreshState = () => {\n      if (!onRefresh) return;\n      currentIndex.current = 0;\n      startElmObserver.current = null;\n      lastElmObserver.current = null;\n      listRef.current = null;\n      setListItems([]);\n      cssUpdating.current = false;\n      initList.current = false;\n      refApplied.current = false;\n      prevPage.current = undefined;\n      goingToTop.current = false;\n      onRefresh();\n    };\n    return (\n      <>\n        {renderList() && showRefresh && currentIndex.current === 0 ? (\n          <>\n            {RefreshButton ? (\n              <div\n                onClick={refreshState}\n                className=\"IS-refresh-button-custom\"\n                style={{\n                  borderRadius: refreshButtonStyle?.borderRadius ?? \"none\",\n                  boxShadow: refreshButtonStyle?.boxShadow ?? \"none\",\n                }}\n              >\n                <RefreshButton />\n              </div>\n            ) : (\n              <div onClick={refreshState} className=\"IS-refresh-button\">\n                Refresh\n              </div>\n            )}\n          </>\n        ) : null}\n      </>\n    );\n  };\n\n  return (\n    <div\n      className=\"IS-list-container\"\n      style={{ height: height, position: \"relative\" }}\n    >\n      {renderRefreshList()}\n      {renderScrollTopView()}\n      {renderList() ? (\n        <List\n          listItems={listItems}\n          startElmRef={applyRef() ? startElmRef : null}\n          lastElmRef={applyRef() ? lastElmRef : null}\n          listRef={listRef}\n          loading={loading}\n          Card={Card}\n          listElementHeight={listElementHeight}\n          listGap={listGap}\n          LoadingList={LoadingList}\n          LoadingMore={LoadingMore}\n        />\n      ) : (\n        <div className=\"IS-loading IS-h-100\">\n          {LoadingList ? <LoadingList /> : <div>Loading...</div>}\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default Scroll;\n","import { useEffect, useState } from \"react\";\n\ninterface DataObject {\n  [key: string]: any; // Define specific properties as needed\n}\n\ninterface ChunkedData {\n  [key: number]: DataObject[]; // Key as number, value as an object\n}\n\nconst ChunkedData: ChunkedData = {}; // Object with number keys and object values\n\nvar totalPages = 0;\nvar totalItems = 0;\n\nfunction useFixedList(\n  chunkSize: number = 10,\n  listType: \"FIXED\" | \"DYNAMIC\",\n  DB: Array<{ [key: string]: any }>\n) {\n  const [nextPage, setNextPage] = useState<number>(0);\n  const [list, setList] = useState<Array<DataObject>>([]);\n  const [hasMore, setHasMore] = useState(true);\n\n  const fetchData = (page: number) => {\n    if (page < 1 || !hasMore || !ChunkedData[page]) {\n      return;\n    }\n\n    setList((lst) => [...lst, ...ChunkedData[page]]);\n    setNextPage(page + 1);\n\n    if (page + 1 > totalPages) {\n      setHasMore(false);\n    }\n  };\n\n  const createChunks = () => {\n    let pg = 1;\n    for (let i = 0; i < DB.length; i += chunkSize) {\n      const chunk = DB.slice(i, i + chunkSize);\n      ChunkedData[pg] = chunk;\n      ++pg;\n      ++totalPages;\n    }\n    totalItems = totalPages * chunkSize;\n    setNextPage(1);\n  };\n\n  useEffect(() => {\n    if (listType === \"FIXED\" && DB.length) {\n      createChunks();\n    }\n  }, [DB, listType]);\n\n  const reset = () => {\n    setHasMore(true);\n    setList([]);\n    totalPages = 0;\n    totalItems = 0;\n    setNextPage(1);\n  };\n\n  if (listType === \"DYNAMIC\") {\n    // If listType is DYNAMIC, return default values or empty state\n    return {\n      totalItems: 0,\n      list: [],\n      hasMore: false,\n      nextPage: 0,\n      fetchData: () => {},\n      reset,\n    };\n  }\n\n  return {\n    totalItems,\n    list,\n    hasMore,\n    nextPage,\n    fetchData,\n    reset,\n  };\n}\n\nexport default useFixedList;\n","import React, { useEffect } from \"react\";\nimport { InfiniteScrollProps } from \"./types\";\nimport Scroll from \"./Scroll\";\nimport useFixedList from \"./useFixedList\";\n\nconst InfiniteVertualScroll: React.FC<InfiniteScrollProps> = ({\n  totalItems,\n  list,\n  hasMore,\n  loading,\n  nextPage,\n  fetchData,\n  chunkSize,\n  Card,\n  height,\n  listElementHeight,\n  listGap,\n  LoadingList,\n  LoadingMore,\n  goToTop,\n  refreshList,\n  listType,\n}) => {\n  const {\n    totalItems: fixedTotalItems,\n    list: fixedList,\n    hasMore: fixedHasMore,\n    nextPage: fixedNextPage,\n    fetchData: fixedFetchData,\n    reset: fixedReset,\n  } = useFixedList(chunkSize, listType, list);\n\n  useEffect(() => {\n    if (fixedNextPage === 1 && listType === \"FIXED\") {\n      fixedFetchData(fixedNextPage);\n    }\n    return;\n  }, [fixedNextPage, listType]);\n\n  return (\n    <Scroll\n      totalItems={listType === \"FIXED\" ? fixedTotalItems : totalItems}\n      hasMore={listType === \"FIXED\" ? fixedHasMore : hasMore}\n      loading={listType === \"FIXED\" ? false : loading}\n      nextPage={listType === \"FIXED\" ? fixedNextPage : nextPage}\n      fetchData={listType === \"FIXED\" ? fixedFetchData : fetchData}\n      list={listType === \"FIXED\" ? fixedList : list}\n      chunkSize={chunkSize}\n      Card={Card}\n      height={height}\n      listElementHeight={listElementHeight}\n      listGap={listGap}\n      LoadingList={LoadingList}\n      LoadingMore={LoadingMore}\n      goToTop={goToTop}\n      refreshList={{\n        ...refreshList,\n        onRefresh:\n          listType === \"FIXED\"\n            ? () => {\n                fixedReset();\n                if (refreshList && refreshList.onRefresh) {\n                  refreshList.onRefresh();\n                }\n              }\n            : refreshList && refreshList.onRefresh\n            ? refreshList.onRefresh\n            : () => {},\n      }}\n    />\n  );\n};\n\nexport default InfiniteVertualScroll;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}